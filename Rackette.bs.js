// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Read$Rackette = require("./Read.bs.js");
var CS17SetupRackette$Rackette = require("./CS17SetupRackette.bs.js");

function plus(numlst) {
  if (!numlst) {
    return Pervasives.failwith("invalid input addition");
  }
  var x = numlst.hd;
  if (x.TAG !== /* NumV */0) {
    return Pervasives.failwith("invalid input addition");
  }
  var match = numlst.tl;
  if (!match) {
    return Pervasives.failwith("invalid input addition");
  }
  var y = match.hd;
  if (y.TAG === /* NumV */0 && !match.tl) {
    return {
            TAG: /* NumV */0,
            _0: x._0 + y._0 | 0
          };
  } else {
    return Pervasives.failwith("invalid input addition");
  }
}

function subtraction(numlst) {
  if (!numlst) {
    return Pervasives.failwith("invalid input subtraction");
  }
  var x = numlst.hd;
  if (x.TAG !== /* NumV */0) {
    return Pervasives.failwith("invalid input subtraction");
  }
  var match = numlst.tl;
  if (!match) {
    return Pervasives.failwith("invalid input subtraction");
  }
  var y = match.hd;
  if (y.TAG === /* NumV */0 && !match.tl) {
    return {
            TAG: /* NumV */0,
            _0: x._0 - y._0 | 0
          };
  } else {
    return Pervasives.failwith("invalid input subtraction");
  }
}

function multiplication(numlst) {
  if (!numlst) {
    return Pervasives.failwith("invalid input multiplication");
  }
  var x = numlst.hd;
  if (x.TAG !== /* NumV */0) {
    return Pervasives.failwith("invalid input multiplication");
  }
  var match = numlst.tl;
  if (!match) {
    return Pervasives.failwith("invalid input multiplication");
  }
  var y = match.hd;
  if (y.TAG === /* NumV */0 && !match.tl) {
    return {
            TAG: /* NumV */0,
            _0: Math.imul(x._0, y._0)
          };
  } else {
    return Pervasives.failwith("invalid input multiplication");
  }
}

function division(numlst) {
  if (!numlst) {
    return Pervasives.failwith("invalid input division");
  }
  var x = numlst.hd;
  if (x.TAG !== /* NumV */0) {
    return Pervasives.failwith("invalid input division");
  }
  var match = numlst.tl;
  if (!match) {
    return Pervasives.failwith("invalid input division");
  }
  var y = match.hd;
  if (y.TAG === /* NumV */0 && !match.tl) {
    return {
            TAG: /* NumV */0,
            _0: Caml_int32.div(x._0, y._0)
          };
  } else {
    return Pervasives.failwith("invalid input division");
  }
}

function remi(numlst) {
  if (!numlst) {
    return Pervasives.failwith("invalid input remainder");
  }
  var x = numlst.hd;
  if (x.TAG !== /* NumV */0) {
    return Pervasives.failwith("invalid input remainder");
  }
  var match = numlst.tl;
  if (!match) {
    return Pervasives.failwith("invalid input remainder");
  }
  var y = match.hd;
  if (y.TAG === /* NumV */0 && !match.tl) {
    return {
            TAG: /* NumV */0,
            _0: Caml_int32.mod_(x._0, y._0)
          };
  } else {
    return Pervasives.failwith("invalid input remainder");
  }
}

function eq(numlst) {
  if (!numlst) {
    return Pervasives.failwith("invalid input num equal");
  }
  var x = numlst.hd;
  if (x.TAG !== /* NumV */0) {
    return Pervasives.failwith("invalid input num equal");
  }
  var match = numlst.tl;
  if (!match) {
    return Pervasives.failwith("invalid input num equal");
  }
  var y = match.hd;
  if (y.TAG === /* NumV */0 && !match.tl) {
    return {
            TAG: /* BoolV */1,
            _0: x._0 === y._0
          };
  } else {
    return Pervasives.failwith("invalid input num equal");
  }
}

function great(numlst) {
  if (!numlst) {
    return Pervasives.failwith("invalid input greater than");
  }
  var x = numlst.hd;
  if (x.TAG !== /* NumV */0) {
    return Pervasives.failwith("invalid input greater than");
  }
  var match = numlst.tl;
  if (!match) {
    return Pervasives.failwith("invalid input greater than");
  }
  var y = match.hd;
  if (y.TAG === /* NumV */0 && !match.tl) {
    return {
            TAG: /* BoolV */1,
            _0: x._0 > y._0
          };
  } else {
    return Pervasives.failwith("invalid input greater than");
  }
}

function small(numlst) {
  if (!numlst) {
    return Pervasives.failwith("invalid input less than");
  }
  var x = numlst.hd;
  if (x.TAG !== /* NumV */0) {
    return Pervasives.failwith("invalid input less than");
  }
  var match = numlst.tl;
  if (!match) {
    return Pervasives.failwith("invalid input less than");
  }
  var y = match.hd;
  if (y.TAG === /* NumV */0 && !match.tl) {
    return {
            TAG: /* BoolV */1,
            _0: x._0 < y._0
          };
  } else {
    return Pervasives.failwith("invalid input less than");
  }
}

function greq(numlst) {
  if (!numlst) {
    return Pervasives.failwith("invalid input greater than or equal to");
  }
  var x = numlst.hd;
  if (x.TAG !== /* NumV */0) {
    return Pervasives.failwith("invalid input greater than or equal to");
  }
  var match = numlst.tl;
  if (!match) {
    return Pervasives.failwith("invalid input greater than or equal to");
  }
  var y = match.hd;
  if (y.TAG === /* NumV */0 && !match.tl) {
    return {
            TAG: /* BoolV */1,
            _0: x._0 >= y._0
          };
  } else {
    return Pervasives.failwith("invalid input greater than or equal to");
  }
}

function smeq(numlst) {
  if (!numlst) {
    return Pervasives.failwith("invalid input less than or equal to");
  }
  var x = numlst.hd;
  if (x.TAG !== /* NumV */0) {
    return Pervasives.failwith("invalid input less than or equal to");
  }
  var match = numlst.tl;
  if (!match) {
    return Pervasives.failwith("invalid input less than or equal to");
  }
  var y = match.hd;
  if (y.TAG === /* NumV */0 && !match.tl) {
    return {
            TAG: /* BoolV */1,
            _0: x._0 <= y._0
          };
  } else {
    return Pervasives.failwith("invalid input less than or equal to");
  }
}

function equality(alst) {
  if (!alst) {
    return Pervasives.failwith("invalid input equality");
  }
  var x = alst.hd;
  switch (x.TAG | 0) {
    case /* NumV */0 :
        var match = alst.tl;
        if (!match) {
          return Pervasives.failwith("invalid input equality");
        }
        var y = match.hd;
        if (y.TAG === /* NumV */0) {
          if (match.tl) {
            return Pervasives.failwith("invalid input equality");
          } else {
            return {
                    TAG: /* BoolV */1,
                    _0: x._0 === y._0
                  };
          }
        }
        break;
    case /* BoolV */1 :
        var match$1 = alst.tl;
        if (!match$1) {
          return Pervasives.failwith("invalid input equality");
        }
        var y$1 = match$1.hd;
        if (y$1.TAG === /* BoolV */1) {
          if (match$1.tl) {
            return Pervasives.failwith("invalid input equality");
          } else {
            return {
                    TAG: /* BoolV */1,
                    _0: x._0 === y$1._0
                  };
          }
        }
        break;
    case /* ListV */2 :
        var match$2 = alst.tl;
        if (!match$2) {
          return Pervasives.failwith("invalid input equality");
        }
        var y$2 = match$2.hd;
        if (y$2.TAG === /* ListV */2) {
          if (match$2.tl) {
            return Pervasives.failwith("invalid input equality");
          } else {
            return {
                    TAG: /* BoolV */1,
                    _0: x._0 === y$2._0
                  };
          }
        }
        break;
    case /* BuiltinV */3 :
    case /* ClosureV */4 :
        break;
    
  }
  var match$3 = alst.tl;
  if (match$3 && !match$3.tl) {
    return {
            TAG: /* BoolV */1,
            _0: false
          };
  } else {
    return Pervasives.failwith("invalid input equality");
  }
}

function isNum(lst) {
  if (lst) {
    if (lst.hd.TAG === /* NumV */0) {
      if (lst.tl) {
        if (lst.tl) {
          return Pervasives.failwith("invalid input isnum must be one argument");
        } else {
          return {
                  TAG: /* BoolV */1,
                  _0: false
                };
        }
      } else {
        return {
                TAG: /* BoolV */1,
                _0: true
              };
      }
    } else if (lst.tl) {
      return Pervasives.failwith("invalid input isnum must be one argument");
    } else {
      return {
              TAG: /* BoolV */1,
              _0: false
            };
    }
  } else {
    return Pervasives.failwith("invalid input isnum cannot be empty");
  }
}

function isZero(lst) {
  if (!lst) {
    return Pervasives.failwith("invalid input is input zero, must be one argument num");
  }
  var match = lst.hd;
  if (match.TAG === /* NumV */0) {
    if (match._0 !== 0) {
      if (lst.tl) {
        return Pervasives.failwith("invalid input is input zero, must be one argument num");
      } else {
        return {
                TAG: /* BoolV */1,
                _0: false
              };
      }
    } else if (lst.tl) {
      return Pervasives.failwith("invalid input is input zero, must be one argument num");
    } else {
      return {
              TAG: /* BoolV */1,
              _0: true
            };
    }
  } else {
    return Pervasives.failwith("invalid input is input zero, must be one argument num");
  }
}

function contain(lst) {
  if (!lst) {
    return Pervasives.failwith("invalid input expect two arguments");
  }
  var match = lst.tl;
  var hd = lst.hd;
  if (!match) {
    return Pervasives.failwith("invalid input expect two arguments");
  }
  var match$1 = match.hd;
  if (match$1.TAG !== /* ListV */2) {
    if (match.tl) {
      return Pervasives.failwith("invalid input expect two arguments");
    } else {
      return Pervasives.failwith("invalid input second item must be list");
    }
  }
  var match$2 = match$1._0;
  if (match$2) {
    if (match.tl) {
      return Pervasives.failwith("invalid input expect two arguments");
    } else {
      return {
              TAG: /* ListV */2,
              _0: {
                hd: hd,
                tl: {
                  hd: match$2.hd,
                  tl: match$2.tl
                }
              }
            };
    }
  } else if (match.tl) {
    return Pervasives.failwith("invalid input expect two arguments");
  } else {
    return {
            TAG: /* ListV */2,
            _0: {
              hd: hd,
              tl: /* [] */0
            }
          };
  }
}

function firstLst(lst) {
  if (!lst) {
    return Pervasives.failwith("invalid input first cannot be empty list");
  }
  var match = lst.hd;
  if (match.TAG !== /* ListV */2) {
    return Pervasives.failwith("invalid input first must be a list");
  }
  var match$1 = match._0;
  if (match$1 && !lst.tl) {
    return match$1.hd;
  } else {
    return Pervasives.failwith("invalid input first must be a list");
  }
}

function restLst(lst) {
  if (!lst) {
    return Pervasives.failwith("invalid input first cannot be empty list");
  }
  var match = lst.hd;
  if (match.TAG !== /* ListV */2) {
    return Pervasives.failwith("invalid input rest must be a list");
  }
  var match$1 = match._0;
  if (match$1 && !lst.tl) {
    return {
            TAG: /* ListV */2,
            _0: match$1.tl
          };
  } else {
    return Pervasives.failwith("invalid input rest must be a list");
  }
}

function isEmpty(lst) {
  if (!lst) {
    return Pervasives.failwith("invalid input empty? must be a list");
  }
  var match = lst.hd;
  if (match.TAG === /* ListV */2) {
    if (match._0) {
      if (lst.tl) {
        return Pervasives.failwith("invalid input empty? must be a list");
      } else {
        return {
                TAG: /* BoolV */1,
                _0: false
              };
      }
    } else if (lst.tl) {
      return Pervasives.failwith("invalid input empty? must be a list");
    } else {
      return {
              TAG: /* BoolV */1,
              _0: true
            };
    }
  } else {
    return Pervasives.failwith("invalid input empty? must be a list");
  }
}

function isCons(lst) {
  if (!lst) {
    return Pervasives.failwith("invalid input cons? must be a list");
  }
  var match = lst.hd;
  if (match.TAG === /* ListV */2) {
    if (match._0) {
      if (lst.tl) {
        return Pervasives.failwith("invalid input cons? must be a list");
      } else {
        return {
                TAG: /* BoolV */1,
                _0: true
              };
      }
    } else if (lst.tl) {
      return Pervasives.failwith("invalid input cons? must be a list");
    } else {
      return {
              TAG: /* BoolV */1,
              _0: false
            };
    }
  } else {
    return Pervasives.failwith("invalid input cons? must be a list");
  }
}

function isNot(lst) {
  if (!lst) {
    return Pervasives.failwith("invalid input not must be a boolean");
  }
  var match = lst.hd;
  if (match.TAG === /* BoolV */1) {
    if (match._0) {
      if (lst.tl) {
        return Pervasives.failwith("invalid input not must be a boolean");
      } else {
        return {
                TAG: /* BoolV */1,
                _0: false
              };
      }
    } else if (lst.tl) {
      return Pervasives.failwith("invalid input not must be a boolean");
    } else {
      return {
              TAG: /* BoolV */1,
              _0: true
            };
    }
  } else {
    return Pervasives.failwith("invalid input not must be a boolean");
  }
}

var initialTle_0 = [
  /* Name */{
    _0: "+"
  },
  {
    TAG: /* BuiltinV */3,
    _0: {
      printedRep: "<builtin-proc-+>",
      bProc: plus
    }
  }
];

var initialTle_1 = {
  hd: [
    /* Name */{
      _0: "-"
    },
    {
      TAG: /* BuiltinV */3,
      _0: {
        printedRep: "<builtin-proc-->",
        bProc: subtraction
      }
    }
  ],
  tl: {
    hd: [
      /* Name */{
        _0: "*"
      },
      {
        TAG: /* BuiltinV */3,
        _0: {
          printedRep: "<builtin-proc-*>",
          bProc: multiplication
        }
      }
    ],
    tl: {
      hd: [
        /* Name */{
          _0: "/"
        },
        {
          TAG: /* BuiltinV */3,
          _0: {
            printedRep: "<builtin-proc-/>",
            bProc: division
          }
        }
      ],
      tl: {
        hd: [
          /* Name */{
            _0: "remainder"
          },
          {
            TAG: /* BuiltinV */3,
            _0: {
              printedRep: "<builtin-proc-rem>",
              bProc: remi
            }
          }
        ],
        tl: {
          hd: [
            /* Name */{
              _0: "="
            },
            {
              TAG: /* BuiltinV */3,
              _0: {
                printedRep: "<builtin-proc-=>",
                bProc: eq
              }
            }
          ],
          tl: {
            hd: [
              /* Name */{
                _0: ">"
              },
              {
                TAG: /* BuiltinV */3,
                _0: {
                  printedRep: "<builtin-proc->>",
                  bProc: great
                }
              }
            ],
            tl: {
              hd: [
                /* Name */{
                  _0: "<"
                },
                {
                  TAG: /* BuiltinV */3,
                  _0: {
                    printedRep: "<builtin-proc-<>",
                    bProc: small
                  }
                }
              ],
              tl: {
                hd: [
                  /* Name */{
                    _0: "<="
                  },
                  {
                    TAG: /* BuiltinV */3,
                    _0: {
                      printedRep: "<builtin-proc-<=>",
                      bProc: smeq
                    }
                  }
                ],
                tl: {
                  hd: [
                    /* Name */{
                      _0: ">="
                    },
                    {
                      TAG: /* BuiltinV */3,
                      _0: {
                        printedRep: "<builtin-proc->=>",
                        bProc: greq
                      }
                    }
                  ],
                  tl: {
                    hd: [
                      /* Name */{
                        _0: "equal?"
                      },
                      {
                        TAG: /* BuiltinV */3,
                        _0: {
                          printedRep: "<builtin-proc-equal?>",
                          bProc: equality
                        }
                      }
                    ],
                    tl: {
                      hd: [
                        /* Name */{
                          _0: "number?"
                        },
                        {
                          TAG: /* BuiltinV */3,
                          _0: {
                            printedRep: "<builtin-proc-number?>",
                            bProc: isNum
                          }
                        }
                      ],
                      tl: {
                        hd: [
                          /* Name */{
                            _0: "zero?"
                          },
                          {
                            TAG: /* BuiltinV */3,
                            _0: {
                              printedRep: "<builtin-proc-zero?>",
                              bProc: isZero
                            }
                          }
                        ],
                        tl: {
                          hd: [
                            /* Name */{
                              _0: "cons"
                            },
                            {
                              TAG: /* BuiltinV */3,
                              _0: {
                                printedRep: "<builtin-proc-cons>",
                                bProc: contain
                              }
                            }
                          ],
                          tl: {
                            hd: [
                              /* Name */{
                                _0: "first"
                              },
                              {
                                TAG: /* BuiltinV */3,
                                _0: {
                                  printedRep: "<builtin-proc-first>",
                                  bProc: firstLst
                                }
                              }
                            ],
                            tl: {
                              hd: [
                                /* Name */{
                                  _0: "rest"
                                },
                                {
                                  TAG: /* BuiltinV */3,
                                  _0: {
                                    printedRep: "<builtin-proc-rest>",
                                    bProc: restLst
                                  }
                                }
                              ],
                              tl: {
                                hd: [
                                  /* Name */{
                                    _0: "empty?"
                                  },
                                  {
                                    TAG: /* BuiltinV */3,
                                    _0: {
                                      printedRep: "<builtin-proc-empty?>",
                                      bProc: isEmpty
                                    }
                                  }
                                ],
                                tl: {
                                  hd: [
                                    /* Name */{
                                      _0: "cons?"
                                    },
                                    {
                                      TAG: /* BuiltinV */3,
                                      _0: {
                                        printedRep: "<builtin-proc-cons?>",
                                        bProc: isCons
                                      }
                                    }
                                  ],
                                  tl: {
                                    hd: [
                                      /* Name */{
                                        _0: "not"
                                      },
                                      {
                                        TAG: /* BuiltinV */3,
                                        _0: {
                                          printedRep: "<builtin-proc-not>",
                                          bProc: isNot
                                        }
                                      }
                                    ],
                                    tl: /* [] */0
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
};

var initialTle = {
  hd: initialTle_0,
  tl: initialTle_1
};

function lambdaHelp(listC) {
  switch (listC.TAG | 0) {
    case /* NumberC */0 :
    case /* SymbolC */1 :
        return Pervasives.failwith("invalid input lambdaHelp");
    case /* ListC */2 :
        var match = listC._0;
        if (!match) {
          return Pervasives.failwith("invalid input lambdaHelp");
        }
        var x = match.hd;
        switch (x.TAG | 0) {
          case /* SymbolC */1 :
              var tl = match.tl;
              var x$1 = x._0;
              if (tl) {
                return {
                        hd: /* Name */{
                          _0: x$1
                        },
                        tl: lambdaHelp({
                              TAG: /* ListC */2,
                              _0: tl
                            })
                      };
              } else {
                return {
                        hd: /* Name */{
                          _0: x$1
                        },
                        tl: /* [] */0
                      };
              }
          case /* NumberC */0 :
          case /* ListC */2 :
              return Pervasives.failwith("invalid input lambdaHelp");
          
        }
    
  }
}

function letHelp(input) {
  switch (input.TAG | 0) {
    case /* NumberC */0 :
    case /* SymbolC */1 :
        return Pervasives.failwith("letHelp must take in a list of concrete program pieces");
    case /* ListC */2 :
        var x = input._0;
        if (!x) {
          return Pervasives.failwith("invalid input letHelp needs ListC(SymbolC(string)...)");
        }
        var match = x.hd;
        switch (match.TAG | 0) {
          case /* NumberC */0 :
          case /* SymbolC */1 :
              return Pervasives.failwith("invalid input letHelp needs ListC(SymbolC(string)...)");
          case /* ListC */2 :
              var match$1 = match._0;
              if (!match$1) {
                return Pervasives.failwith("invalid input letHelp needs ListC(SymbolC(string)...)");
              }
              var nom = match$1.hd;
              switch (nom.TAG | 0) {
                case /* SymbolC */1 :
                    var match$2 = match$1.tl;
                    if (!match$2) {
                      return Pervasives.failwith("invalid input letHelp needs ListC(SymbolC(string)...)");
                    }
                    if (match$2.tl) {
                      return Pervasives.failwith("invalid input letHelp needs ListC(SymbolC(string)...)");
                    }
                    var tl = x.tl;
                    var expr = match$2.hd;
                    var nom$1 = nom._0;
                    if (tl) {
                      return {
                              hd: {
                                pairName: /* Name */{
                                  _0: nom$1
                                },
                                pairExpr: parseExpression(expr)
                              },
                              tl: letHelp({
                                    TAG: /* ListC */2,
                                    _0: tl
                                  })
                            };
                    } else {
                      return {
                              hd: {
                                pairName: /* Name */{
                                  _0: nom$1
                                },
                                pairExpr: parseExpression(expr)
                              },
                              tl: /* [] */0
                            };
                    }
                case /* NumberC */0 :
                case /* ListC */2 :
                    return Pervasives.failwith("invalid input letHelp needs ListC(SymbolC(string)...)");
                
              }
          
        }
    
  }
}

function condHelp(lst) {
  if (!lst) {
    return Pervasives.failwith("cond needs a list of bool, expr pairs");
  }
  var match = lst.hd;
  switch (match.TAG | 0) {
    case /* NumberC */0 :
    case /* SymbolC */1 :
        return Pervasives.failwith("condHelp expects [ListC([...]...)]");
    case /* ListC */2 :
        var match$1 = match._0;
        if (!match$1) {
          return Pervasives.failwith("condHelp expects [ListC([...]...)]");
        }
        var match$2 = match$1.tl;
        if (!match$2) {
          return Pervasives.failwith("condHelp expects [ListC([...]...)]");
        }
        if (match$2.tl) {
          return Pervasives.failwith("condHelp expects [ListC([...]...)]");
        }
        var tl = lst.tl;
        var resultExpr = match$2.hd;
        var condExpr = match$1.hd;
        if (tl) {
          return {
                  hd: {
                    conditionExpr: parseExpression(condExpr),
                    resultExpr: parseExpression(resultExpr)
                  },
                  tl: condHelp(tl)
                };
        } else {
          return {
                  hd: {
                    conditionExpr: parseExpression(condExpr),
                    resultExpr: parseExpression(resultExpr)
                  },
                  tl: /* [] */0
                };
        }
    
  }
}

function parseExpression(_cpe) {
  while(true) {
    var cpe = _cpe;
    switch (cpe.TAG | 0) {
      case /* NumberC */0 :
          return {
                  TAG: /* NumE */0,
                  _0: cpe._0
                };
      case /* SymbolC */1 :
          var x = cpe._0;
          switch (x) {
            case "empty" :
                return /* EmptyE */0;
            case "false" :
                return {
                        TAG: /* BoolE */1,
                        _0: false
                      };
            case "true" :
                return {
                        TAG: /* BoolE */1,
                        _0: true
                      };
            default:
              return {
                      TAG: /* NameE */2,
                      _0: /* Name */{
                        _0: x
                      }
                    };
          }
      case /* ListC */2 :
          var lst = cpe._0;
          if (!lst) {
            return Pervasives.failwith("rackette cannot handle an empty list");
          }
          var x$1 = lst.hd;
          switch (x$1.TAG | 0) {
            case /* SymbolC */1 :
                var x$2 = x$1._0;
                var exit = 0;
                if (x$2 === "if") {
                  var match = lst.tl;
                  if (!match) {
                    return Pervasives.failwith("expected three arguments");
                  }
                  var match$1 = match.tl;
                  if (!match$1) {
                    return Pervasives.failwith("expected three arguments");
                  }
                  var match$2 = match$1.tl;
                  if (match$2 && !match$2.tl) {
                    return {
                            TAG: /* IfE */5,
                            _0: {
                              boolExpr: parseExpression(match.hd),
                              trueExpr: parseExpression(match$1.hd),
                              falseExpr: parseExpression(match$2.hd)
                            }
                          };
                  } else {
                    return Pervasives.failwith("expected three arguments");
                  }
                }
                var match$3 = lst.tl;
                if (match$3) {
                  var match$4 = match$3.tl;
                  if (match$4 && !match$4.tl) {
                    var exp2 = match$4.hd;
                    var exp1 = match$3.hd;
                    switch (x$2) {
                      case "and" :
                          return {
                                  TAG: /* AndE */3,
                                  _0: parseExpression(exp1),
                                  _1: parseExpression(exp2)
                                };
                      case "cond" :
                          return {
                                  TAG: /* CondE */6,
                                  _0: condHelp({
                                        hd: exp1,
                                        tl: {
                                          hd: exp2,
                                          tl: /* [] */0
                                        }
                                      })
                                };
                      case "lambda" :
                          return {
                                  TAG: /* LambdaE */7,
                                  _0: {
                                    nameList: lambdaHelp(exp1),
                                    lambdaBody: parseExpression(exp2)
                                  }
                                };
                      case "let" :
                          return {
                                  TAG: /* LetE */8,
                                  _0: {
                                    letPairs: letHelp(exp1),
                                    letBody: parseExpression(exp2)
                                  }
                                };
                      case "or" :
                          return {
                                  TAG: /* OrE */4,
                                  _0: parseExpression(exp1),
                                  _1: parseExpression(exp2)
                                };
                      default:
                        return {
                                TAG: /* ApplicationE */9,
                                _0: {
                                  hd: {
                                    TAG: /* NameE */2,
                                    _0: /* Name */{
                                      _0: x$2
                                    }
                                  },
                                  tl: {
                                    hd: parseExpression(exp1),
                                    tl: {
                                      hd: parseExpression(exp2),
                                      tl: /* [] */0
                                    }
                                  }
                                }
                              };
                    }
                  } else {
                    exit = 2;
                  }
                } else {
                  exit = 2;
                }
                if (exit === 2) {
                  switch (x$2) {
                    case "and" :
                        return Pervasives.failwith("and: expected two arguments");
                    case "cond" :
                        return {
                                TAG: /* CondE */6,
                                _0: condHelp(lst.tl)
                              };
                    case "lambda" :
                        return Pervasives.failwith("lambda: expected two arguments");
                    case "let" :
                        return Pervasives.failwith("let: expected two arguments");
                    case "or" :
                        return Pervasives.failwith("or: expected two arguments");
                    default:
                      if (!lst.tl) {
                        return {
                                TAG: /* NameE */2,
                                _0: /* Name */{
                                  _0: x$2
                                }
                              };
                      }
                      
                  }
                }
                break;
            case /* NumberC */0 :
            case /* ListC */2 :
                break;
            
          }
          var tl = lst.tl;
          if (tl) {
            return {
                    TAG: /* ApplicationE */9,
                    _0: {
                      hd: parseExpression(x$1),
                      tl: {
                        hd: parseExpression({
                              TAG: /* ListC */2,
                              _0: tl
                            }),
                        tl: /* [] */0
                      }
                    }
                  };
          }
          _cpe = x$1;
          continue ;
          break;
      
    }
  };
}

function parseDefinition(cpd) {
  switch (cpd.TAG | 0) {
    case /* NumberC */0 :
    case /* SymbolC */1 :
        return Pervasives.failwith("define expects variable name followed by expression: incorrect format");
    case /* ListC */2 :
        var match = cpd._0;
        if (!match) {
          return Pervasives.failwith("define expects variable name followed by expression: incorrect format");
        }
        var match$1 = match.hd;
        switch (match$1.TAG | 0) {
          case /* SymbolC */1 :
              if (match$1._0 !== "define") {
                return Pervasives.failwith("define expects variable name followed by expression: incorrect format");
              }
              var match$2 = match.tl;
              if (!match$2) {
                return Pervasives.failwith("define expects variable name followed by expression: incorrect format");
              }
              var x = match$2.hd;
              switch (x.TAG | 0) {
                case /* SymbolC */1 :
                    var match$3 = match$2.tl;
                    if (match$3 && !match$3.tl) {
                      return [
                              /* Name */{
                                _0: x._0
                              },
                              parseExpression(match$3.hd)
                            ];
                    } else {
                      return Pervasives.failwith("define expects variable name followed by expression: incorrect format");
                    }
                case /* NumberC */0 :
                case /* ListC */2 :
                    return Pervasives.failwith("define expects variable name followed by expression: incorrect format");
                
              }
          case /* NumberC */0 :
          case /* ListC */2 :
              return Pervasives.failwith("define expects variable name followed by expression: incorrect format");
          
        }
    
  }
}

function parsePiece(input) {
  switch (input.TAG | 0) {
    case /* NumberC */0 :
    case /* SymbolC */1 :
        return {
                TAG: /* Expression */1,
                _0: parseExpression(input)
              };
    case /* ListC */2 :
        var match = input._0;
        if (!match) {
          return {
                  TAG: /* Expression */1,
                  _0: parseExpression(input)
                };
        }
        var match$1 = match.hd;
        switch (match$1.TAG | 0) {
          case /* SymbolC */1 :
              if (match$1._0 === "define") {
                return {
                        TAG: /* Definition */0,
                        _0: parseDefinition(input)
                      };
              } else {
                return {
                        TAG: /* Expression */1,
                        _0: parseExpression(input)
                      };
              }
          case /* NumberC */0 :
          case /* ListC */2 :
              return {
                      TAG: /* Expression */1,
                      _0: parseExpression(input)
                    };
          
        }
    
  }
}

function parse(input) {
  return List.map(parsePiece, input);
}

var extendEnv = List.append;

function defLookUp(_env, nom) {
  while(true) {
    var env = _env;
    if (!env) {
      return ;
    }
    var match = env.hd;
    if (Caml_obj.caml_equal(match[0], nom)) {
      return match[1];
    }
    _env = env.tl;
    continue ;
  };
}

function letPairHelper(tle, local, lst) {
  if (!lst) {
    return /* [] */0;
  }
  var hd = lst.hd;
  return {
          hd: [
            hd.pairName,
            $$eval(tle, local, hd.pairExpr)
          ],
          tl: letPairHelper(tle, local, lst.tl)
        };
}

function $$eval(tle, _local, _expr) {
  while(true) {
    var expr = _expr;
    var local = _local;
    var allEnv = List.append(local, tle);
    if (typeof expr === "number") {
      return {
              TAG: /* ListV */2,
              _0: /* [] */0
            };
    }
    switch (expr.TAG | 0) {
      case /* NumE */0 :
          return {
                  TAG: /* NumV */0,
                  _0: expr._0
                };
      case /* BoolE */1 :
          return {
                  TAG: /* BoolV */1,
                  _0: expr._0
                };
      case /* NameE */2 :
          var va = defLookUp(allEnv, expr._0);
          if (va !== undefined) {
            return va;
          } else {
            return Pervasives.failwith("name not bounded to value, cannot eval");
          }
      case /* AndE */3 :
          var match = $$eval(tle, local, expr._0);
          if (match.TAG !== /* BoolV */1) {
            return Pervasives.failwith("and expects two bool expr");
          }
          if (!match._0) {
            return {
                    TAG: /* BoolV */1,
                    _0: false
                  };
          }
          var match$1 = $$eval(tle, local, expr._1);
          if (match$1.TAG === /* BoolV */1) {
            if (match$1._0) {
              return {
                      TAG: /* BoolV */1,
                      _0: true
                    };
            } else {
              return {
                      TAG: /* BoolV */1,
                      _0: false
                    };
            }
          } else {
            return Pervasives.failwith("and expects two bool expr");
          }
      case /* OrE */4 :
          var match$2 = $$eval(tle, local, expr._0);
          if (match$2.TAG !== /* BoolV */1) {
            return Pervasives.failwith("or expects two bool expr");
          }
          if (match$2._0) {
            return {
                    TAG: /* BoolV */1,
                    _0: true
                  };
          }
          var match$3 = $$eval(tle, local, expr._1);
          if (match$3.TAG === /* BoolV */1) {
            if (match$3._0) {
              return {
                      TAG: /* BoolV */1,
                      _0: true
                    };
            } else {
              return {
                      TAG: /* BoolV */1,
                      _0: false
                    };
            }
          } else {
            return Pervasives.failwith("or expects two bool expr");
          }
      case /* IfE */5 :
          var ifData1 = expr._0;
          var match$4 = $$eval(tle, local, ifData1.boolExpr);
          if (match$4.TAG !== /* BoolV */1) {
            return Pervasives.failwith("if-expr must eval to bool");
          }
          if (match$4._0) {
            _expr = ifData1.trueExpr;
            continue ;
          }
          _expr = ifData1.falseExpr;
          continue ;
      case /* CondE */6 :
          var match$5 = expr._0;
          if (!match$5) {
            return Pervasives.failwith("cond expr or app expr cannot contain empty list");
          }
          var hd = match$5.hd;
          var match$6 = $$eval(tle, local, hd.conditionExpr);
          if (match$6.TAG !== /* BoolV */1) {
            return Pervasives.failwith("condition expr of cond must eval to bool");
          }
          if (match$6._0) {
            _expr = hd.resultExpr;
            continue ;
          }
          _expr = {
            TAG: /* CondE */6,
            _0: match$5.tl
          };
          continue ;
      case /* LambdaE */7 :
          var lambdaData1 = expr._0;
          return {
                  TAG: /* ClosureV */4,
                  _0: {
                    cNameList: lambdaData1.nameList,
                    cExpr: lambdaData1.lambdaBody,
                    cEnv: local
                  }
                };
      case /* LetE */8 :
          var letData1 = expr._0;
          _expr = letData1.letBody;
          _local = List.append(letPairHelper(tle, local, letData1.letPairs), local);
          continue ;
      case /* ApplicationE */9 :
          var match$7 = expr._0;
          if (!match$7) {
            return Pervasives.failwith("cond expr or app expr cannot contain empty list");
          }
          var hd$1 = $$eval(tle, local, match$7.hd);
          if (hd$1.TAG === /* BuiltinV */3) {
            return Curry._1(hd$1._0.bProc, List.map((function (param) {
                              return $$eval(tle, /* [] */0, param);
                            }), match$7.tl));
          } else {
            return Pervasives.failwith("syntax error for builtin proc or closure");
          }
      
    }
  };
}

function addDefinition(env, param) {
  var nom = param[0];
  var newBinding_1 = $$eval(env, env, param[1]);
  var newBinding = [
    nom,
    newBinding_1
  ];
  var match = defLookUp(env, nom);
  if (match !== undefined) {
    return Pervasives.failwith("name already bound to value");
  } else {
    return {
            hd: newBinding,
            tl: env
          };
  }
}

function stringOfValue(aValue) {
  switch (aValue.TAG | 0) {
    case /* NumV */0 :
        return String(aValue._0);
    case /* BoolV */1 :
        return Pervasives.string_of_bool(aValue._0);
    case /* ListV */2 :
        var match = aValue._0;
        if (match) {
          return "(cons " + (stringOfValue(match.hd) + (" " + (stringOfValue({
                            TAG: /* ListV */2,
                            _0: match.tl
                          }) + ")")));
        } else {
          return "empty";
        }
    case /* BuiltinV */3 :
        return aValue._0.printedRep;
    case /* ClosureV */4 :
        return "user-defined procedure";
    
  }
}

function $$process(pieces) {
  var processHelper = function (_tle, _pieces) {
    while(true) {
      var pieces = _pieces;
      var tle = _tle;
      if (!pieces) {
        return /* [] */0;
      }
      var d = pieces.hd;
      if (d.TAG !== /* Definition */0) {
        return {
                hd: $$eval(tle, /* [] */0, d._0),
                tl: processHelper(tle, pieces.tl)
              };
      }
      _pieces = pieces.tl;
      _tle = addDefinition(tle, d._0);
      continue ;
    };
  };
  return processHelper(initialTle, pieces);
}

function rackette(program) {
  return List.map(stringOfValue, $$process(List.map(parsePiece, Read$Rackette.Reader.readAll(program))));
}

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression({
          TAG: /* SymbolC */1,
          _0: "empty"
        }), /* EmptyE */0, "parse empty expression");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression(Read$Rackette.Reader.read("empty")), /* EmptyE */0, "read and parse empty expression");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("empty")))), "empty", "read all the way for empty");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("1")))), "1", "read all the way for a num");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression(Read$Rackette.Reader.read("(+ 1 5)")), {
      TAG: /* ApplicationE */9,
      _0: {
        hd: {
          TAG: /* NameE */2,
          _0: /* Name */{
            _0: "+"
          }
        },
        tl: {
          hd: {
            TAG: /* NumE */0,
            _0: 1
          },
          tl: {
            hd: {
              TAG: /* NumE */0,
              _0: 5
            },
            tl: /* [] */0
          }
        }
      }
    }, "read and parse 1 + 5");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("(+ 1 5)")))), "6", "stringOfValue buildin proc +");

CS17SetupRackette$Rackette.checkExpect(rackette("(+ 1 5)"), {
      hd: "6",
      tl: /* [] */0
    }, "rackette of buildin proc");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression(Read$Rackette.Reader.read("(let ((x 5)) x)")), {
      TAG: /* LetE */8,
      _0: {
        letPairs: {
          hd: {
            pairName: /* Name */{
              _0: "x"
            },
            pairExpr: {
              TAG: /* NumE */0,
              _0: 5
            }
          },
          tl: /* [] */0
        },
        letBody: {
          TAG: /* NameE */2,
          _0: /* Name */{
            _0: "x"
          }
        }
      }
    }, "read and parse for let expression");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression(Read$Rackette.Reader.read("(let ((x 5)(y 3))(+ x y))")), {
      TAG: /* LetE */8,
      _0: {
        letPairs: {
          hd: {
            pairName: /* Name */{
              _0: "x"
            },
            pairExpr: {
              TAG: /* NumE */0,
              _0: 5
            }
          },
          tl: {
            hd: {
              pairName: /* Name */{
                _0: "y"
              },
              pairExpr: {
                TAG: /* NumE */0,
                _0: 3
              }
            },
            tl: /* [] */0
          }
        },
        letBody: {
          TAG: /* ApplicationE */9,
          _0: {
            hd: {
              TAG: /* NameE */2,
              _0: /* Name */{
                _0: "+"
              }
            },
            tl: {
              hd: {
                TAG: /* NameE */2,
                _0: /* Name */{
                  _0: "x"
                }
              },
              tl: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "y"
                  }
                },
                tl: /* [] */0
              }
            }
          }
        }
      }
    }, "read and parse for let expression");

CS17SetupRackette$Rackette.checkExpectAbstractProgram(List.map(parsePiece, {
          hd: Read$Rackette.Reader.read("(lambda (x) x)"),
          tl: /* [] */0
        }), {
      hd: {
        TAG: /* Expression */1,
        _0: {
          TAG: /* LambdaE */7,
          _0: {
            nameList: {
              hd: /* Name */{
                _0: "x"
              },
              tl: /* [] */0
            },
            lambdaBody: {
              TAG: /* NameE */2,
              _0: /* Name */{
                _0: "x"
              }
            }
          }
        }
      },
      tl: /* [] */0
    }, "read and parse for lambda expressions with one name");

CS17SetupRackette$Rackette.checkExpectAbstractProgram(List.map(parsePiece, {
          hd: Read$Rackette.Reader.read("(lambda (x y) (+ x y))"),
          tl: /* [] */0
        }), {
      hd: {
        TAG: /* Expression */1,
        _0: {
          TAG: /* LambdaE */7,
          _0: {
            nameList: {
              hd: /* Name */{
                _0: "x"
              },
              tl: {
                hd: /* Name */{
                  _0: "y"
                },
                tl: /* [] */0
              }
            },
            lambdaBody: {
              TAG: /* ApplicationE */9,
              _0: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "+"
                  }
                },
                tl: {
                  hd: {
                    TAG: /* NameE */2,
                    _0: /* Name */{
                      _0: "x"
                    }
                  },
                  tl: {
                    hd: {
                      TAG: /* NameE */2,
                      _0: /* Name */{
                        _0: "y"
                      }
                    },
                    tl: /* [] */0
                  }
                }
              }
            }
          }
        }
      },
      tl: /* [] */0
    }, "read and parse for lambda expressions with two names");

CS17SetupRackette$Rackette.checkExpectAbstractProgram(List.map(parsePiece, {
          hd: Read$Rackette.Reader.read("(if (positive? -5) (3) 2)"),
          tl: /* [] */0
        }), {
      hd: {
        TAG: /* Expression */1,
        _0: {
          TAG: /* IfE */5,
          _0: {
            boolExpr: {
              TAG: /* ApplicationE */9,
              _0: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "positive?"
                  }
                },
                tl: {
                  hd: {
                    TAG: /* NumE */0,
                    _0: -5
                  },
                  tl: /* [] */0
                }
              }
            },
            trueExpr: {
              TAG: /* NumE */0,
              _0: 3
            },
            falseExpr: {
              TAG: /* NumE */0,
              _0: 2
            }
          }
        }
      },
      tl: /* [] */0
    }, "read and parse for if statement");

CS17SetupRackette$Rackette.checkExpectAbstractProgram(List.map(parsePiece, {
          hd: Read$Rackette.Reader.read("(and true 5)"),
          tl: /* [] */0
        }), {
      hd: {
        TAG: /* Expression */1,
        _0: {
          TAG: /* AndE */3,
          _0: {
            TAG: /* BoolE */1,
            _0: true
          },
          _1: {
            TAG: /* NumE */0,
            _0: 5
          }
        }
      },
      tl: /* [] */0
    }, "read and parse for and statement");

CS17SetupRackette$Rackette.checkExpect(rackette("(and true false)"), {
      hd: "false",
      tl: /* [] */0
    }, "read and parse for and statement");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression(Read$Rackette.Reader.read("(cond\n   ((positive? -5) 1)\n   ((zero? -5) 2)\n   ((positive? 5) 3))")), {
      TAG: /* CondE */6,
      _0: {
        hd: {
          conditionExpr: {
            TAG: /* ApplicationE */9,
            _0: {
              hd: {
                TAG: /* NameE */2,
                _0: /* Name */{
                  _0: "positive?"
                }
              },
              tl: {
                hd: {
                  TAG: /* NumE */0,
                  _0: -5
                },
                tl: /* [] */0
              }
            }
          },
          resultExpr: {
            TAG: /* NumE */0,
            _0: 1
          }
        },
        tl: {
          hd: {
            conditionExpr: {
              TAG: /* ApplicationE */9,
              _0: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "zero?"
                  }
                },
                tl: {
                  hd: {
                    TAG: /* NumE */0,
                    _0: -5
                  },
                  tl: /* [] */0
                }
              }
            },
            resultExpr: {
              TAG: /* NumE */0,
              _0: 2
            }
          },
          tl: {
            hd: {
              conditionExpr: {
                TAG: /* ApplicationE */9,
                _0: {
                  hd: {
                    TAG: /* NameE */2,
                    _0: /* Name */{
                      _0: "positive?"
                    }
                  },
                  tl: {
                    hd: {
                      TAG: /* NumE */0,
                      _0: 5
                    },
                    tl: /* [] */0
                  }
                }
              },
              resultExpr: {
                TAG: /* NumE */0,
                _0: 3
              }
            },
            tl: /* [] */0
          }
        }
      }
    }, "parseExpression for cond statement");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("(number? 1)")))), "true", "check expect buildin proc is number");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("(remainder 4 2)")))), "0", "check expect buildin proc remainder");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("(equal? 1 1)")))), "true", "check expect buildin proc equal?");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("(cons 1 empty)")))), "(cons 1 empty)", "check expect buildin proc cons");

CS17SetupRackette$Rackette.checkExpect(rackette("(cond ((= 7 8) 6) (true 4))"), {
      hd: "4",
      tl: /* [] */0
    }, "rackette of cond expr");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(+ 3 false)");
      }), "invalid input addition");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(+ 3 false 4)");
      }), "syntax error for builtin proc or closure");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(- 3 4 5)");
      }), "syntax error for builtin proc or closure");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(* true false)");
      }), "invalid input multiplication");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(/ true false)");
      }), "invalid input division");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(= 3)");
      }), "invalid input num equal");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(> 1)");
      }), "invalid input greater than");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(< 1 true)");
      }), "invalid input less than");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(>= 1)");
      }), "invalid input greater than or equal to");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(<= 1)");
      }), "invalid input less than or equal to");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(equal? 1 2 3)");
      }), "syntax error for builtin proc or closure");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(number? 1 2)");
      }), "invalid input isnum must be one argument");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(zero? 1 2)");
      }), "invalid input is input zero, must be one argument num");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(cons 1)");
      }), "invalid input expect two arguments");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(cons 1 2)");
      }), "invalid input second item must be list");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(first 1)");
      }), "invalid input first must be a list");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(rest 1)");
      }), "invalid input rest must be a list");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(empty? 5)");
      }), "invalid input empty? must be a list");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(cons? 2)");
      }), "invalid input cons? must be a list");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(not 2)");
      }), "invalid input not must be a boolean");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("()");
      }), "rackette cannot handle an empty list");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(lambda x y)");
      }), "invalid input lambdaHelp");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(let (4 x) 4)");
      }), "invalid input letHelp needs ListC(SymbolC(string)...)");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(let x y)");
      }), "letHelp must take in a list of concrete program pieces");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(let (x y))");
      }), "let: expected two arguments");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(cond)");
      }), "cond needs a list of bool, expr pairs");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(and true)");
      }), "and: expected two arguments");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(and 5 true)");
      }), "and expects two bool expr");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(and)");
      }), "and: expected two arguments");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(or 5)");
      }), "or: expected two arguments");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(or 5 6)");
      }), "or expects two bool expr");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(lambda 5)");
      }), "lambda: expected two arguments");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(lambda)");
      }), "lambda: expected two arguments");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(let 5)");
      }), "let: expected two arguments");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(let)");
      }), "let: expected two arguments");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(define 6 7)");
      }), "define expects variable name followed by expression: incorrect format");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(if 9 9 0)");
      }), "if-expr must eval to bool");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(cond (false 6) (8 true))");
      }), "condition expr of cond must eval to bool");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(if true)");
      }), "expected three arguments");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(cond (false 6) (8 true))");
      }), "condition expr of cond must eval to bool");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(cond (false 6) (8 7))");
      }), "condition expr of cond must eval to bool");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(define x 7)(define x 8)");
      }), "name already bound to value");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(define x 7)(define x 8)");
      }), "name already bound to value");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(define x 7)(define x 8)");
      }), "name already bound to value");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(define x 7)(define x 8)");
      }), "name already bound to value");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(3 4 5)");
      }), "syntax error for builtin proc or closure");

exports.plus = plus;
exports.subtraction = subtraction;
exports.multiplication = multiplication;
exports.division = division;
exports.remi = remi;
exports.eq = eq;
exports.great = great;
exports.small = small;
exports.greq = greq;
exports.smeq = smeq;
exports.equality = equality;
exports.isNum = isNum;
exports.isZero = isZero;
exports.contain = contain;
exports.firstLst = firstLst;
exports.restLst = restLst;
exports.isEmpty = isEmpty;
exports.isCons = isCons;
exports.isNot = isNot;
exports.initialTle = initialTle;
exports.lambdaHelp = lambdaHelp;
exports.letHelp = letHelp;
exports.condHelp = condHelp;
exports.parseExpression = parseExpression;
exports.parseDefinition = parseDefinition;
exports.parsePiece = parsePiece;
exports.parse = parse;
exports.extendEnv = extendEnv;
exports.defLookUp = defLookUp;
exports.letPairHelper = letPairHelper;
exports.$$eval = $$eval;
exports.addDefinition = addDefinition;
exports.stringOfValue = stringOfValue;
exports.$$process = $$process;
exports.rackette = rackette;
/*  Not a pure module */
